import "reflect-metadata";
import chai, { expect } from "chai";
import sinon from "sinon";
import sinonChai from "sinon-chai";
import jwt from "jsonwebtoken";
import { JwtService } from "../../../src/services/JwtService";
import RedisHandler from "../../../src/primingApi/RedisHandler";
import { IApplicationConfig } from "../../../src/types/IConfigurationTypes";
import { TestConfig } from "../utils/testConfig";
import { TestLogger } from "../utils/testLogger";
import BaseRestError from "../../../src/errors/BaseRestError";
import KeyPemFiles from "../../../src/enums/KeyPemFiles";

chai.use(sinonChai);

const createConfig = ({ iss, aud }: { iss?: string; aud?: string } = {}) => ({
  ...TestConfig,
  IdP: {
    CUSTOMER: {
      ISS: iss || "http://localhost:8080/realms/customer",
      JWKS_URI: "customer_uri",
      AUD: aud || "customer_audience",
    },
    AGENT: {
      ISS: iss || "http://localhost:8080/realms/agent",
      JWKS_URI: "agent_uri",
      AUD: aud || "agent_audience",
      GROUPS: ["admin", "support"],
    },
  },
}) as IApplicationConfig;

describe("JwtService Tests", () => {
  let jwtService: JwtService;
  let redisHandlerMock: sinon.SinonStubbedInstance<RedisHandler>;
  let jwtStub: sinon.SinonStub;

  beforeEach(() => {
    redisHandlerMock = sinon.createStubInstance(RedisHandler);
    jwtService = new JwtService(redisHandlerMock, createConfig(), TestLogger);
  });

  afterEach(() => {
    sinon.restore();
  });

  it("should verify a valid token successfully", async () => {
    const decodedPayload = {
      iss: "http://localhost:8080/realms/customer",
      aud: "customer_audience",
    };
    const pemFile = "mockPemFile";

    sinon.stub(jwt, "decode").returns({ payload: decodedPayload, header: { kid: "key-id" } });
    redisHandlerMock.getData.resolves(JSON.stringify({ "key-id": pemFile }));
    jwtStub = sinon.stub(jwt, "verify").callsFake(() => decodedPayload);

    const result = await jwtService.verifyToken("validToken");
    expect(result).to.have.property("jwtPayload");
    expect(result).to.have.property("isAgent", false);
  });

  it("should throw an error for a malformed token", async () => {
    sinon.stub(jwt, "decode").returns(null);

    try {
      await jwtService.verifyToken("invalidToken");
    } catch (e: any) {
      expect(e).to.be.instanceOf(BaseRestError);
      expect(e.message).to.equal("PAYMENT-UI: Invalid or malformed token: invalidToken");
      expect(e.status).to.equal(401);
    }
  });

  it("should throw an error when AUD is missing in token payload", async () => {
    const decodedPayload = {
      iss: "http://localhost:8080/realms/customer",
    };

    sinon.stub(jwt, "decode").returns({ payload: decodedPayload, header: { kid: "key-id" } });

    try {
      await jwtService.verifyToken("missingAudToken");
    } catch (e: any) {
      expect(e).to.be.instanceOf(BaseRestError);
      expect(e.message).to.equal("PAYMENT-UI:: Missing AUD field: missingAudToken");
      expect(e.status).to.equal(403);
    }
  });

  it("should throw an error for an invalid issuer", async () => {
    const decodedPayload = {
      iss: "http://invalid-issuer",
      aud: "customer_audience",
    };

    sinon.stub(jwt, "decode").returns({ payload: decodedPayload, header: { kid: "key-id" } });

    try {
      await jwtService.verifyToken("invalidIssuerToken");
    } catch (e: any) {
      expect(e).to.be.instanceOf(BaseRestError);
      expect(e.message).to.equal("PAYMENT-UI :: iss field http://invalid-issuer is not valid");
      expect(e.status).to.equal(401);
    }
  });

  it("should throw an error when no matching key ID is found in Redis", async () => {
    const decodedPayload = {
      iss: "http://localhost:8080/realms/customer",
      aud: "customer_audience",
    };

    sinon.stub(jwt, "decode").returns({ payload: decodedPayload, header: { kid: "invalid-key-id" } });
    redisHandlerMock.getData.resolves(JSON.stringify({}));

    try {
      await jwtService.verifyToken("noKeyIdToken");
    } catch (e: any) {
      expect(e).to.be.instanceOf(BaseRestError);
      expect(e.message).to.equal("PAYMENT-UI :: JWT error: secret or public key must be provided");
      expect(e.status).to.equal(403);
    }
  });

  it("should throw an error when agent groups do not match", async () => {
    const decodedPayload = {
      iss: "http://localhost:8080/realms/agent",
      aud: "agent_audience",
      groups: ["user"],
    };

    sinon.stub(jwt, "decode").returns({ payload: decodedPayload, header: { kid: "key-id" } });
    redisHandlerMock.getData.resolves(JSON.stringify({ "key-id": "mockPemFile" }));
    jwtStub = sinon.stub(jwt, "verify").callsFake(() => decodedPayload);

    try {
      await jwtService.verifyToken("invalidGroupToken");
    } catch (e: any) {
      expect(e).to.be.instanceOf(BaseRestError);
      expect(e.message).to.equal("PAYMENT-UI :: iss field http://localhost:8080/realms/agent is not valid");
      expect(e.status).to.equal(403);
    }
  });

  it("should throw TokenExpiredError when the token is expired", async () => {
    const decodedPayload = {
      iss: "http://localhost:8080/realms/customer",
      aud: "customer_audience",
    };
    const pemFile = "mockPemFile";

    sinon.stub(jwt, "decode").returns({ payload: decodedPayload, header: { kid: "key-id" } });
    redisHandlerMock.getData.resolves(JSON.stringify({ "key-id": pemFile }));
    jwtStub = sinon.stub(jwt, "verify").throws(new jwt.TokenExpiredError("Token expired", new Date()));

    try {
      await jwtService.verifyToken("expiredToken");
    } catch (e: any) {
      expect(e).to.be.instanceOf(BaseRestError);
      expect(e.message).to.contain("Token expired at");
      expect(e.status).to.equal(401);
    }
  });

  it("should throw NotBeforeError when the token's nbf claim is in the future", async () => {
    const decodedPayload = {
      iss: "http://localhost:8080/realms/customer",
      aud: "customer_audience",
    };
    const pemFile = "mockPemFile";

    sinon.stub(jwt, "decode").returns({ payload: decodedPayload, header: { kid: "key-id" } });
    redisHandlerMock.getData.resolves(JSON.stringify({ "key-id": pemFile }));
    jwtStub = sinon.stub(jwt, "verify").throws(new jwt.NotBeforeError("Token not active", new Date()));

    try {
      await jwtService.verifyToken("notBeforeToken");
    } catch (e: any) {
      expect(e).to.be.instanceOf(BaseRestError);
      expect(e.message).to.equal("PAYMENT-UI :: Token not active: Token not active");
      expect(e.status).to.equal(401);
    }
  });

  it("should throw JWT error for generic JsonWebTokenError", async () => {
    const decodedPayload = {
      iss: "http://localhost:8080/realms/customer",
      aud: "customer_audience",
    };
    const pemFile = "mockPemFile";

    sinon.stub(jwt, "decode").returns({ payload: decodedPayload, header: { kid: "key-id" } });
    redisHandlerMock.getData.resolves(JSON.stringify({ "key-id": pemFile }));
    jwtStub = sinon.stub(jwt, "verify").throws(new jwt.JsonWebTokenError("JWT malformed"));

    try {
      await jwtService.verifyToken("jwtErrorToken");
    } catch (e: any) {
      expect(e).to.be.instanceOf(BaseRestError);
      expect(e.message).to.equal("PAYMENT-UI :: JWT error: JWT malformed");
      expect(e.status).to.equal(403);
    }
  });
});








import { expect } from "chai";
import sinon from "sinon";
import getBenefitDetails from "../path/to/getBenefitDetails";
import ServiceStack from "../path/to/services/ServiceStack";

describe("getBenefitDetails", () => {
  let req: any;
  let res: any;
  let next: sinon.SinonStub;
  let loggerMock: any;
  let serviceStackMock: any;

  beforeEach(() => {
    // Mock request object
    req = {
      query: {},
    };

    // Mock response object
    res = {
      status: sinon.stub().returnsThis(),
      json: sinon.stub().returnsThis(),
      render: sinon.stub(),
    };

    // Mock next function
    next = sinon.stub();

    // Mock logger
    loggerMock = {
      info: sinon.spy(),
      error: sinon.spy(),
    };

    // Mock ServiceStack
    serviceStackMock = {
      paymentDetailsClientService: {
        getAwardDetails: sinon.stub(),
      },
    };
  });

  afterEach(() => {
    sinon.restore();
  });

  it("should handle successful response from ServiceStack", async () => {
    const mockSasResponse = {
      statusCode: "200",
      data: {
        sas_award_details: [
          {
            statusCode: 200,
            data: {
              award_start_date: "2023-01-01",
              award_end_date: "2023-12-31",
              estimated_next_payment: 1000,
            },
          },
        ],
      },
    };

    serviceStackMock.paymentDetailsClientService.getAwardDetails.resolves(mockSasResponse);

    const mockReq = {
      query: {
        guid: "test-guid",
      },
    };

    await getBenefitDetails(serviceStackMock, loggerMock)(mockReq, res, next);

    expect(res.render.calledOnce).to.be.true;
    expect(res.render.firstCall.args[0]).to.equal("pages/benefit-details.njk");
    expect(res.render.firstCall.args[1]).to.include.keys("sasAward");
    expect(res.status.called).to.be.false; // No error status
    expect(next.called).to.be.false;
  });

  it("should handle an error response from ServiceStack", async () => {
    const mockError = new Error("Service error");
    serviceStackMock.paymentDetailsClientService.getAwardDetails.rejects(mockError);

    await getBenefitDetails(serviceStackMock, loggerMock)(req, res, next);

    expect(loggerMock.error.calledOnce).to.be.true;
    expect(loggerMock.error.firstCall.args[0]).to.contain("benefitDetails");
    expect(res.render.calledOnce).to.be.true;
    expect(res.render.firstCall.args[0]).to.equal("pages/benefit-details.njk");
    expect(res.render.firstCall.args[1]).to.deep.equal({});
    expect(next.called).to.be.false;
  });

  it("should handle a non-200 status code response from ServiceStack", async () => {
    const mockSasResponse = {
      statusCode: "404",
    };

    serviceStackMock.paymentDetailsClientService.getAwardDetails.resolves(mockSasResponse);

    await getBenefitDetails(serviceStackMock, loggerMock)(req, res, next);

    expect(res.status.calledOnceWith(200)).to.be.true;
    expect(res.json.calledOnceWith("Error")).to.be.true;
    expect(res.render.called).to.be.false;
    expect(next.called).to.be.false;
  });

  it("should handle missing query parameter", async () => {
    req.query = {}; // No 'guid'

    await getBenefitDetails(serviceStackMock, loggerMock)(req, res, next);

    expect(res.status.calledOnceWith(200)).to.be.true;
    expect(res.json.calledOnceWith("Error")).to.be.true;
    expect(res.render.called).to.be.false;
    expect(next.called).to.be.false;
  });

  it("should handle valid benefit parameter in the query", async () => {
    req.query.benefit = "esa";

    const mockSasResponse = {
      statusCode: "200",
      data: {
        sas_award_details: [
          {
            statusCode: 200,
            data: {
              award_start_date: "2023-01-01",
              award_end_date: "2023-12-31",
              estimated_next_payment: 1000,
            },
          },
        ],
      },
    };

    serviceStackMock.paymentDetailsClientService.getAwardDetails.resolves(mockSasResponse);

    await getBenefitDetails(serviceStackMock, loggerMock)(req, res, next);

    expect(res.render.calledOnce).to.be.true;
    expect(res.render.firstCall.args[0]).to.equal("pages/benefit-details.njk");
    expect(res.render.firstCall.args[1]).to.include.keys("sasAward");
    expect(next.called).to.be.false;
  });
});

