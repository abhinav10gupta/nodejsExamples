const chai = require('chai');
const sinon = require('sinon');
const expect = chai.expect;

// Mock dependencies
const ServiceStack = require('../services/ServiceStack'); // Path to your ServiceStack
const Logger = require('@dwp/node-logger'); // Path to your Logger
const verifyTokenMiddleware = require('../middleware/verifyTokenMiddleware'); // Path to your middleware
const { Request, Response } = require('express');

// Mock services
let serviceStackMock, loggerMock, req, res, next;

describe('verifyTokenMiddleware', () => {
    beforeEach(() => {
        // Create mocks and stubs
        serviceStackMock = {
            redisCacheService: {
                getPayload: sinon.stub(),
            },
            jwtService: {
                verifyToken: sinon.stub(),
            },
        };

        loggerMock = {
            error: sinon.stub(),
            info: sinon.stub(),
        };

        req = {
            headers: {},
            query: {},
            session: {},
        };

        res = {
            locals: {},
            status: sinon.stub().returnsThis(),
            json: sinon.stub(),
        };

        next = sinon.stub();
    });

    afterEach(() => {
        sinon.restore();
    });

    it('should process a valid token and primed payload', async () => {
        req.headers['x-access-token'] = 'valid-token';
        req.query.sessionId = 'valid-session';
        req.session.cacheId = 'valid-cache';

        serviceStackMock.jwtService.verifyToken.resolves({
            isAgent: true,
            jwtPayload: { guid: '12345' },
        });

        serviceStackMock.redisCacheService.getPayload.resolves(
            JSON.stringify({
                renderAsFragment: true,
                callbacks: { consumerCallbackComplete: 'callbackUrl' },
                context: { dwpGUID: 'testGUID' },
            })
        );

        await verifyTokenMiddleware(serviceStackMock, loggerMock)(req, res, next);

        expect(serviceStackMock.jwtService.verifyToken.calledOnce).to.be.true;
        expect(res.locals.isAgent).to.be.true;
        expect(res.locals.renderAsFragment).to.be.true;
        expect(next.calledOnce).to.be.true;
    });

    it('should throw error when x-access-token header is missing', async () => {
        req.headers = {}; // Missing x-access-token

        await verifyTokenMiddleware(serviceStackMock, loggerMock)(req, res, next);

        expect(loggerMock.error.calledOnce).to.be.true;
        expect(loggerMock.error.args[0][0]).to.include('Missing header key: x-access-token');
        expect(res.status.calledWith(401)).to.be.true;
        expect(next.called).to.be.false;
    });

    it('should throw error when x-access-token header is empty', async () => {
        req.headers['x-access-token'] = ''; // Empty x-access-token

        await verifyTokenMiddleware(serviceStackMock, loggerMock)(req, res, next);

        expect(loggerMock.error.calledOnce).to.be.true;
        expect(loggerMock.error.args[0][0]).to.include('Empty value for key: x-access-token');
        expect(res.status.calledWith(401)).to.be.true;
        expect(next.called).to.be.false;
    });

    it('should handle invalid Redis cache ID', async () => {
        req.headers['x-access-token'] = 'valid-token';
        req.query.sessionId = 'invalid-session';

        serviceStackMock.jwtService.verifyToken.resolves({
            isAgent: false,
        });

        req.session.cacheId = undefined; // Simulating invalid cache

        await verifyTokenMiddleware(serviceStackMock, loggerMock)(req, res, next);

        expect(loggerMock.error.calledOnce).to.be.true;
        expect(loggerMock.error.args[0][0]).to.include('Error extracting payload from cache');
        expect(next.calledOnce).to.be.true; // Allow middleware to proceed
    });

    it('should log error and return 500 for unexpected errors', async () => {
        req.headers['x-access-token'] = 'valid-token';

        serviceStackMock.jwtService.verifyToken.throws(new Error('Unexpected error'));

        await verifyTokenMiddleware(serviceStackMock, loggerMock)(req, res, next);

        expect(loggerMock.error.calledOnce).to.be.true;
        expect(loggerMock.error.args[0][0]).to.include('Unexpected error');
        expect(res.status.calledWith(500)).to.be.true;
        expect(next.called).to.be.false;
    });

    it('should identify request as primed and valid', async () => {
        req.headers['x-access-token'] = 'valid-token';
        req.query.sessionId = 'valid-session';
        req.session.cacheId = 'valid-cache';

        serviceStackMock.jwtService.verifyToken.resolves({
            isAgent: false,
            jwtPayload: { guid: '12345' },
        });

        await verifyTokenMiddleware(serviceStackMock, loggerMock)(req, res, next);

        expect(res.locals.isAgent).to.be.false;
        expect(loggerMock.info.calledWithMatch(/primed and valid/)).to.be.true;
        expect(next.calledOnce).to.be.true;
    });
});
